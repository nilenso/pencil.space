shadow$provide.module$node_modules$roughjs$bin$renderer=function(global,require,module,exports){function _slicedToArray(arr,i){var JSCompiler_temp=Array.isArray(arr)?arr:void 0;if(!JSCompiler_temp)if(Symbol.iterator in Object(arr)||"[object Arguments]"===Object.prototype.toString.call(arr)){JSCompiler_temp=[];var _n=!0,_d=!1,_e=void 0;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done)&&(JSCompiler_temp.push(_s.value),!i||JSCompiler_temp.length!==i);_n=!0);}catch(err){_d=!0,_e=err}finally{try{if(!_n&&
null!=_i["return"])_i["return"]()}finally{if(_d)throw _e;}}}else JSCompiler_temp=void 0;if(!(arr=JSCompiler_temp))throw new TypeError("Invalid attempt to destructure non-iterable instance");return arr}function line(x1,y1,x2,y2,o){return{type:"path",ops:_doubleLine(x1,y1,x2,y2,o)}}function linearPath(points,close,o){var len=(points||[]).length;if(2<len){for(var ops=[],i=0;i<len-1;i++)ops=ops.concat(_doubleLine(points[i][0],points[i][1],points[i+1][0],points[i+1][1],o));close&&(ops=ops.concat(_doubleLine(points[len-
1][0],points[len-1][1],points[0][0],points[0][1],o)));return{type:"path",ops:ops}}return 2===len?line(points[0][0],points[0][1],points[1][0],points[1][1],o):{type:"path",ops:[]}}function polygon(points,o){return linearPath(points,!0,o)}function ellipse(x,y,width,height,o){width=generateEllipseParams(width,height,o);return ellipseWithParams(x,y,o,width).opset}function generateEllipseParams(width,height,o){var increment=2*Math.PI/Math.max(o.curveStepCount,o.curveStepCount/Math.sqrt(200)*Math.sqrt(2*
Math.PI*Math.sqrt((Math.pow(width/2,2)+Math.pow(height/2,2))/2)));width=Math.abs(width/2);height=Math.abs(height/2);var curveFitRandomness=1-o.curveFitting;width+=_offsetOpt(width*curveFitRandomness,o);height+=_offsetOpt(height*curveFitRandomness,o);return{increment:increment,rx:width,ry:height}}function ellipseWithParams(x,y,o,ellipseParams){var _computeEllipsePoints2=_computeEllipsePoints(ellipseParams.increment,x,y,ellipseParams.rx,ellipseParams.ry,1,ellipseParams.increment*_offset(.1,_offset(.4,
1,o),o),o);_computeEllipsePoints2=_slicedToArray(_computeEllipsePoints2,2);var ap1=_computeEllipsePoints2[0];_computeEllipsePoints2=_computeEllipsePoints2[1];x=_computeEllipsePoints(ellipseParams.increment,x,y,ellipseParams.rx,ellipseParams.ry,1.5,0,o);x=_slicedToArray(x,1)[0];ap1=_curve(ap1,null,o);o=_curve(x,null,o);return{estimatedPoints:_computeEllipsePoints2,opset:{type:"path",ops:ap1.concat(o)}}}function patternFillPolygon(points,o){return(0,_filler.getFiller)(o,helper).fillPolygon(points,o)}
function randOffset(x,o){return _offsetOpt(x,o)}function randOffsetWithRange(min,max,o){return _offset(min,max,o)}function doubleLineOps(x1,y1,x2,y2,o){return _doubleLine(x1,y1,x2,y2,o)}function random(ops){ops.randomizer||(ops.randomizer=new _math.Random(ops.seed||0));return ops.randomizer.next()}function _offset(min,max,ops){return ops.roughness*ops.roughnessGain*(random(ops)*(max-min)+min)}function _offsetOpt(x,ops){return _offset(-x,x,ops)}function _doubleLine(x1,y1,x2,y2,o){var o1=_line(x1,y1,
x2,y2,o,!0,!1);x1=_line(x1,y1,x2,y2,o,!0,!0);return o1.concat(x1)}function _line(x1,y1,x2,y2,o,move,overlay){var lengthSq=Math.pow(x1-x2,2)+Math.pow(y1-y2,2),length=Math.sqrt(lengthSq);o.roughnessGain=200>length?1:500<length?.4:-.0016668*length+1.233334;var offset=o.maxRandomnessOffset||0;offset*offset*100>lengthSq&&(offset=length/10);var halfOffset=offset/2;lengthSq=.2+.2*random(o);length=o.bowing*o.maxRandomnessOffset*(y2-y1)/200;var midDispY=o.bowing*o.maxRandomnessOffset*(x1-x2)/200;length=_offsetOpt(length,
o);midDispY=_offsetOpt(midDispY,o);var ops=[],randomHalf=function(){return _offsetOpt(halfOffset,o)};move&&(overlay?ops.push({op:"move",data:[x1+randomHalf(),y1+randomHalf()]}):ops.push({op:"move",data:[x1+_offsetOpt(offset,o),y1+_offsetOpt(offset,o)]}));overlay?ops.push({op:"bcurveTo",data:[length+x1+(x2-x1)*lengthSq+randomHalf(),midDispY+y1+(y2-y1)*lengthSq+randomHalf(),length+x1+2*(x2-x1)*lengthSq+randomHalf(),midDispY+y1+2*(y2-y1)*lengthSq+randomHalf(),x2+randomHalf(),y2+randomHalf()]}):ops.push({op:"bcurveTo",
data:[length+x1+(x2-x1)*lengthSq+_offsetOpt(offset,o),midDispY+y1+(y2-y1)*lengthSq+_offsetOpt(offset,o),length+x1+2*(x2-x1)*lengthSq+_offsetOpt(offset,o),midDispY+y1+2*(y2-y1)*lengthSq+_offsetOpt(offset,o),x2+_offsetOpt(offset,o),y2+_offsetOpt(offset,o)]});return ops}function _curveWithOffset(points,offset,o){var ps=[];ps.push([points[0][0]+_offsetOpt(offset,o),points[0][1]+_offsetOpt(offset,o)]);ps.push([points[0][0]+_offsetOpt(offset,o),points[0][1]+_offsetOpt(offset,o)]);for(var i=1;i<points.length;i++)ps.push([points[i][0]+
_offsetOpt(offset,o),points[i][1]+_offsetOpt(offset,o)]),i===points.length-1&&ps.push([points[i][0]+_offsetOpt(offset,o),points[i][1]+_offsetOpt(offset,o)]);return _curve(ps,null,o)}function _curve(points,closePoint,o){var len=points.length,ops=[];if(3<len){var b=[],s=1-o.curveTightness;ops.push({op:"move",data:[points[1][0],points[1][1]]});for(var i=1;i+2<len;i++){var cachedVertArray=points[i];b[0]=[cachedVertArray[0],cachedVertArray[1]];b[1]=[cachedVertArray[0]+(s*points[i+1][0]-s*points[i-1][0])/
6,cachedVertArray[1]+(s*points[i+1][1]-s*points[i-1][1])/6];b[2]=[points[i+1][0]+(s*points[i][0]-s*points[i+2][0])/6,points[i+1][1]+(s*points[i][1]-s*points[i+2][1])/6];b[3]=[points[i+1][0],points[i+1][1]];ops.push({op:"bcurveTo",data:[b[1][0],b[1][1],b[2][0],b[2][1],b[3][0],b[3][1]]})}closePoint&&2===closePoint.length&&(points=o.maxRandomnessOffset,ops.push({op:"lineTo",data:[closePoint[0]+_offsetOpt(points,o),closePoint[1]+_offsetOpt(points,o)]}))}else 3===len?(ops.push({op:"move",data:[points[1][0],
points[1][1]]}),ops.push({op:"bcurveTo",data:[points[1][0],points[1][1],points[2][0],points[2][1],points[2][0],points[2][1]]})):2===len&&(ops=ops.concat(_doubleLine(points[0][0],points[0][1],points[1][0],points[1][1],o)));return ops}function _computeEllipsePoints(increment,cx,cy,rx,ry,offset,overlap,o){var corePoints=[],allPoints=[],radOffset=_offsetOpt(.5,o)-Math.PI/2;allPoints.push([_offsetOpt(offset,o)+cx+.9*rx*Math.cos(radOffset-increment),_offsetOpt(offset,o)+cy+.9*ry*Math.sin(radOffset-increment)]);
for(var angle=radOffset;angle<2*Math.PI+radOffset-.01;angle+=increment){var p=[_offsetOpt(offset,o)+cx+rx*Math.cos(angle),_offsetOpt(offset,o)+cy+ry*Math.sin(angle)];corePoints.push(p);allPoints.push(p)}allPoints.push([_offsetOpt(offset,o)+cx+rx*Math.cos(radOffset+2*Math.PI+.5*overlap),_offsetOpt(offset,o)+cy+ry*Math.sin(radOffset+2*Math.PI+.5*overlap)]);allPoints.push([_offsetOpt(offset,o)+cx+.98*rx*Math.cos(radOffset+overlap),_offsetOpt(offset,o)+cy+.98*ry*Math.sin(radOffset+overlap)]);allPoints.push([_offsetOpt(offset,
o)+cx+.9*rx*Math.cos(radOffset+.5*overlap),_offsetOpt(offset,o)+cy+.9*ry*Math.sin(radOffset+.5*overlap)]);return[allPoints,corePoints]}function _arc(increment,cx,cy,rx,ry,strt,stp,offset,o){var radOffset=strt+_offsetOpt(.1,o);strt=[];for(strt.push([_offsetOpt(offset,o)+cx+.9*rx*Math.cos(radOffset-increment),_offsetOpt(offset,o)+cy+.9*ry*Math.sin(radOffset-increment)]);radOffset<=stp;radOffset+=increment)strt.push([_offsetOpt(offset,o)+cx+rx*Math.cos(radOffset),_offsetOpt(offset,o)+cy+ry*Math.sin(radOffset)]);
strt.push([cx+rx*Math.cos(stp),cy+ry*Math.sin(stp)]);strt.push([cx+rx*Math.cos(stp),cy+ry*Math.sin(stp)]);return _curve(strt,null,o)}function _bezierTo(x1,y1,x2,y2,x,y,path,o){for(var ops=[],ros=[o.maxRandomnessOffset||1,(o.maxRandomnessOffset||1)+.5],f=[0,0],i=0;2>i;i++)0===i?ops.push({op:"move",data:[path.x,path.y]}):ops.push({op:"move",data:[path.x+_offsetOpt(ros[0],o),path.y+_offsetOpt(ros[0],o)]}),f=[x+_offsetOpt(ros[i],o),y+_offsetOpt(ros[i],o)],ops.push({op:"bcurveTo",data:[x1+_offsetOpt(ros[i],
o),y1+_offsetOpt(ros[i],o),x2+_offsetOpt(ros[i],o),y2+_offsetOpt(ros[i],o),f[0],f[1]]});path.setPosition(f[0],f[1]);return ops}Object.defineProperty(exports,"__esModule",{value:!0});exports.line=line;exports.linearPath=linearPath;exports.polygon=polygon;exports.rectangle=function(x,y,width,height,o){return polygon([[x,y],[x+width,y],[x+width,y+height],[x,y+height]],o)};exports.curve=function(points,o){var o1=_curveWithOffset(points,1+.2*o.roughness,o);points=_curveWithOffset(points,1.5*(1+.22*o.roughness),
o);return{type:"path",ops:o1.concat(points)}};exports.ellipse=ellipse;exports.generateEllipseParams=generateEllipseParams;exports.ellipseWithParams=ellipseWithParams;exports.arc=function(x,y,width,height,start,stop,closed,roughClosure,o){width=Math.abs(width/2);height=Math.abs(height/2);width+=_offsetOpt(.01*width,o);for(height+=_offsetOpt(.01*height,o);0>start;)start+=2*Math.PI,stop+=2*Math.PI;stop-start>2*Math.PI&&(start=0,stop=2*Math.PI);var arcInc=Math.min(2*Math.PI/o.curveStepCount/2,(stop-start)/
2),o1=_arc(arcInc,x,y,width,height,start,stop,1,o);arcInc=_arc(arcInc,x,y,width,height,start,stop,1.5,o);o1=o1.concat(arcInc);closed&&(roughClosure?(o1=o1.concat(_doubleLine(x,y,x+width*Math.cos(start),y+height*Math.sin(start),o)),o1=o1.concat(_doubleLine(x,y,x+width*Math.cos(stop),y+height*Math.sin(stop),o))):(o1.push({op:"lineTo",data:[x,y]}),o1.push({op:"lineTo",data:[x+width*Math.cos(start),y+height*Math.sin(start)]})));return{type:"path",ops:o1}};exports.svgPath=function(path,o$jscomp$0){path=
(path||"").replace(/\n/g," ").replace(/(-\s)/g,"-").replace("/(ss)/g"," ");path=new _path.RoughPath(path);o$jscomp$0.simplification&&(path=(new _path.PathFitter(path.linearPoints,path.closed)).fit(o$jscomp$0.simplification),path=new _path.RoughPath(path));for(var ops=[],segments=path.segments||[],i=0;i<segments.length;i++){var opList=path;var seg=segments[i],prevSeg=0<i?segments[i-1]:null,o=o$jscomp$0,ops$jscomp$0=[];switch(seg.key){case "M":case "m":var delta="m"===seg.key;2<=seg.data.length&&(prevSeg=
+seg.data[0],seg=+seg.data[1],delta&&(prevSeg+=opList.x,seg+=opList.y),delta=1*(o.maxRandomnessOffset||0),prevSeg+=_offsetOpt(delta,o),seg+=_offsetOpt(delta,o),opList.setPosition(prevSeg,seg),ops$jscomp$0.push({op:"move",data:[prevSeg,seg]}));break;case "L":case "l":prevSeg="l"===seg.key;2<=seg.data.length&&(delta=+seg.data[0],seg=+seg.data[1],prevSeg&&(delta+=opList.x,seg+=opList.y),ops$jscomp$0=ops$jscomp$0.concat(_doubleLine(opList.x,opList.y,delta,seg,o)),opList.setPosition(delta,seg));break;
case "H":case "h":prevSeg="h"===seg.key;seg.data.length&&(seg=+seg.data[0],prevSeg&&(seg+=opList.x),ops$jscomp$0=ops$jscomp$0.concat(_doubleLine(opList.x,opList.y,seg,opList.y,o)),opList.setPosition(seg,opList.y));break;case "V":case "v":prevSeg="v"===seg.key;seg.data.length&&(seg=+seg.data[0],prevSeg&&(seg+=opList.y),ops$jscomp$0=ops$jscomp$0.concat(_doubleLine(opList.x,opList.y,opList.x,seg,o)),opList.setPosition(opList.x,seg));break;case "Z":case "z":opList.first&&(ops$jscomp$0=ops$jscomp$0.concat(_doubleLine(opList.x,
opList.y,opList.first[0],opList.first[1],o)),opList.setPosition(opList.first[0],opList.first[1]),opList.first=null);break;case "C":case "c":var _delta4="c"===seg.key;if(6<=seg.data.length){var x1=+seg.data[0],y1=+seg.data[1];prevSeg=+seg.data[2];delta=+seg.data[3];var _x3=+seg.data[4];seg=+seg.data[5];_delta4&&(x1+=opList.x,prevSeg+=opList.x,_x3+=opList.x,y1+=opList.y,delta+=opList.y,seg+=opList.y);o=_bezierTo(x1,y1,prevSeg,delta,_x3,seg,opList,o);ops$jscomp$0=ops$jscomp$0.concat(o);opList.bezierReflectionPoint=
[_x3+(_x3-prevSeg),seg+(seg-delta)]}break;case "S":case "s":x1="s"===seg.key;if(4<=seg.data.length){delta=+seg.data[0];_x3=+seg.data[1];_delta4=+seg.data[2];seg=+seg.data[3];x1&&(delta+=opList.x,_delta4+=opList.x,_x3+=opList.y,seg+=opList.y);x1=delta;y1=_x3;prevSeg=prevSeg?prevSeg.key:"";var ref=null;if("c"===prevSeg||"C"===prevSeg||"s"===prevSeg||"S"===prevSeg)ref=opList.bezierReflectionPoint;ref&&(x1=ref[0],y1=ref[1]);o=_bezierTo(x1,y1,delta,_x3,_delta4,seg,opList,o);ops$jscomp$0=ops$jscomp$0.concat(o);
opList.bezierReflectionPoint=[_delta4+(_delta4-delta),seg+(seg-_x3)]}break;case "Q":case "q":_delta4="q"===seg.key;4<=seg.data.length&&(prevSeg=+seg.data[0],delta=+seg.data[1],_x3=+seg.data[2],seg=+seg.data[3],_delta4&&(prevSeg+=opList.x,_x3+=opList.x,delta+=opList.y,seg+=opList.y),_delta4=1+.2*o.roughness,x1=1.5*(1+.22*o.roughness),ops$jscomp$0.push({op:"move",data:[opList.x+_offsetOpt(_delta4,o),opList.y+_offsetOpt(_delta4,o)]}),y1=[_x3+_offsetOpt(_delta4,o),seg+_offsetOpt(_delta4,o)],ops$jscomp$0.push({op:"qcurveTo",
data:[prevSeg+_offsetOpt(_delta4,o),delta+_offsetOpt(_delta4,o),y1[0],y1[1]]}),ops$jscomp$0.push({op:"move",data:[opList.x+_offsetOpt(x1,o),opList.y+_offsetOpt(x1,o)]}),y1=[_x3+_offsetOpt(x1,o),seg+_offsetOpt(x1,o)],ops$jscomp$0.push({op:"qcurveTo",data:[prevSeg+_offsetOpt(x1,o),delta+_offsetOpt(x1,o),y1[0],y1[1]]}),opList.setPosition(y1[0],y1[1]),opList.quadReflectionPoint=[_x3+(_x3-prevSeg),seg+(seg-delta)]);break;case "T":case "t":_x3="t"===seg.key;if(2<=seg.data.length){delta=+seg.data[0];seg=
+seg.data[1];_x3&&(delta+=opList.x,seg+=opList.y);_x3=delta;_delta4=seg;prevSeg=prevSeg?prevSeg.key:"";x1=null;if("q"===prevSeg||"Q"===prevSeg||"t"===prevSeg||"T"===prevSeg)x1=opList.quadReflectionPoint;x1&&(_x3=x1[0],_delta4=x1[1]);prevSeg=1+.2*o.roughness;x1=1.5*(1+.22*o.roughness);ops$jscomp$0.push({op:"move",data:[opList.x+_offsetOpt(prevSeg,o),opList.y+_offsetOpt(prevSeg,o)]});y1=[delta+_offsetOpt(prevSeg,o),seg+_offsetOpt(prevSeg,o)];ops$jscomp$0.push({op:"qcurveTo",data:[_x3+_offsetOpt(prevSeg,
o),_delta4+_offsetOpt(prevSeg,o),y1[0],y1[1]]});ops$jscomp$0.push({op:"move",data:[opList.x+_offsetOpt(x1,o),opList.y+_offsetOpt(x1,o)]});y1=[delta+_offsetOpt(x1,o),seg+_offsetOpt(x1,o)];ops$jscomp$0.push({op:"qcurveTo",data:[_x3+_offsetOpt(x1,o),_delta4+_offsetOpt(x1,o),y1[0],y1[1]]});opList.setPosition(y1[0],y1[1]);opList.quadReflectionPoint=[delta+(delta-_x3),seg+(seg-_delta4)]}break;case "A":case "a":if(ref="a"===seg.key,7<=seg.data.length&&(prevSeg=+seg.data[0],delta=+seg.data[1],_x3=+seg.data[2],
_delta4=+seg.data[3],x1=+seg.data[4],y1=+seg.data[5],seg=+seg.data[6],ref&&(y1+=opList.x,seg+=opList.y),y1!==opList.x||seg!==opList.y))if(0===prevSeg||0===delta)ops$jscomp$0=ops$jscomp$0.concat(_doubleLine(opList.x,opList.y,y1,seg,o)),opList.setPosition(y1,seg);else for(ref=0;1>ref;ref++)for(var arcConverter=new _path.RoughArcConverter([opList.x,opList.y],[y1,seg],[prevSeg,delta],_x3,_delta4?!0:!1,x1?!0:!1),segment=arcConverter.getNextSegment();segment;)segment=_bezierTo(segment.cp1[0],segment.cp1[1],
segment.cp2[0],segment.cp2[1],segment.to[0],segment.to[1],opList,o),ops$jscomp$0=ops$jscomp$0.concat(segment),segment=arcConverter.getNextSegment()}(opList=ops$jscomp$0)&&opList.length&&(ops=ops.concat(opList))}return{type:"path",ops:ops}};exports.solidFillPolygon=function(points,o){var ops=[];if(points.length){var offset=o.maxRandomnessOffset||0,len=points.length;if(2<len){ops.push({op:"move",data:[points[0][0]+_offsetOpt(offset,o),points[0][1]+_offsetOpt(offset,o)]});for(var i=1;i<len;i++)ops.push({op:"lineTo",
data:[points[i][0]+_offsetOpt(offset,o),points[i][1]+_offsetOpt(offset,o)]})}}return{type:"fillPath",ops:ops}};exports.patternFillPolygon=patternFillPolygon;exports.patternFillArc=function(x,y,width,height,start,stop,o){width=Math.abs(width/2);height=Math.abs(height/2);width+=_offsetOpt(.01*width,o);for(height+=_offsetOpt(.01*height,o);0>start;)start+=2*Math.PI,stop+=2*Math.PI;stop-start>2*Math.PI&&(start=0,stop=2*Math.PI);for(var increment=(stop-start)/o.curveStepCount,points=[];start<=stop;start+=
increment)points.push([x+width*Math.cos(start),y+height*Math.sin(start)]);points.push([x+width*Math.cos(stop),y+height*Math.sin(stop)]);points.push([x,y]);return patternFillPolygon(points,o)};exports.randOffset=randOffset;exports.randOffsetWithRange=randOffsetWithRange;exports.doubleLineOps=doubleLineOps;var _path=require("module$node_modules$roughjs$bin$path"),_filler=require("module$node_modules$roughjs$bin$fillers$filler"),_math=require("module$node_modules$roughjs$bin$math"),helper={randOffset:randOffset,
randOffsetWithRange:randOffsetWithRange,ellipse:ellipse,doubleLineOps:doubleLineOps}}
//# sourceMappingURL=module$node_modules$roughjs$bin$renderer.js.map
