{"version":3,"sources":["spec_tools/transform.cljc"],"mappings":"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","names":["spec-tools.transform/keyword->string","_","x","cljs.core/Keyword","spec-tools.impl/qualified-name","spec-tools.transform/keyword-or-string->","f","spec","G__10716","G__10717","spec-tools.transform/keyword->","G__10719","G__10720","spec-tools.transform/string->long","e10721","x'","js/parseInt","js/isNaN","js/Error","spec-tools.transform/string->double","e10722","js/parseFloat","spec-tools.transform/string->keyword","cljs.core.keyword","spec-tools.transform/string->boolean","cljs.core._EQ_","spec-tools.transform/string->uuid","e10729","cljs.core/re-find","cljs.core/uuid","spec-tools.transform/string->date","e10734","js/Date","js/goog.date.UtcDateTime.fromIsoString","spec-tools.transform/date->string","cljs.core/inst?","e10737","spec-tools.transform/string->symbol","cljs.core.symbol","spec-tools.transform/string->nil","spec-tools.transform/any->string","spec-tools.transform/number->double","spec-tools.transform/any->any","p__10742","map__10743","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","keys","cljs.core.get","spec-tools.transform/strip-extra-keys","and__4174__auto__","cljs.core/map?","cljs.core/select-keys","p__10745","map__10746","spec-tools.transform/fail-on-extra-keys","clojure.set/subset?","cljs.core/keys","cljs.core/set","p__10748","map__10749","items","spec-tools.transform/strip-extra-values","size","cljs.core/count","cljs.core/vector?","cljs.core.subvec","spec-tools.transform/json-type-decoders","cljs.core.merge","spec-tools.transform/string-type-decoders","spec-tools.transform/strip-extra-keys-type-decoders","spec-tools.transform/fail-on-extra-keys-type-decoders","spec-tools.transform/strip-extra-values-type-decoders","spec-tools.transform/json-type-encoders","spec-tools.transform/string-type-encoders"],"sourcesContent":["(ns spec-tools.transform\n  #?(:cljs (:refer-clojure :exclude [Inst Keyword UUID]))\n  (:require [clojure.spec.alpha :as s]\n            #?@(:cljs [[goog.date.UtcDateTime]\n                       [goog.date.Date]])\n            [clojure.set :as set]\n            [spec-tools.parse :as parse]\n            [clojure.string :as str]\n            [spec-tools.impl :as impl])\n  #?(:clj\n     (:import (java.util Date UUID)\n              (java.time Instant ZoneId)\n              (java.time.format DateTimeFormatter DateTimeFormatterBuilder)\n              (java.time.temporal ChronoField))))\n\n;;\n;; Keywords\n;;\n\n(defn keyword->string [_ x]\n  (if (keyword? x)\n    (impl/qualified-name x)\n    x))\n\n(defn keyword-or-string-> [f]\n  (fn [spec x]\n    (cond\n      (keyword? x) (f spec (keyword->string spec x))\n      (string? x) (f spec x)\n      :else x)))\n\n(defn keyword-> [f]\n  (fn [spec x]\n    (cond\n      (keyword? x) (f spec (keyword->string spec x))\n      :else x)))\n;;\n;; Strings\n;;\n\n(defn string->long [_ x]\n  (if (string? x)\n    (try\n      #?(:clj  (Long/parseLong x)\n         :cljs (let [x' (js/parseInt x 10)]\n                 (if (js/isNaN x') x x')))\n      (catch #?(:clj Exception, :cljs js/Error) _ x))\n    x))\n\n(defn string->double [_ x]\n  (if (string? x)\n    (try\n      #?(:clj  (Double/parseDouble x)\n         :cljs (let [x' (js/parseFloat x)]\n                 (if (js/isNaN x') x x')))\n      (catch #?(:clj Exception, :cljs js/Error) _ x))\n    x))\n\n(defn string->keyword [_ x]\n  (if (string? x)\n    (keyword x)\n    x))\n\n(defn string->boolean [_ x]\n  (if (string? x)\n    (cond\n      (= \"true\" x) true\n      (= \"false\" x) false\n      :else x)\n    x))\n\n(defn string->uuid [_ x]\n  (if (string? x)\n    (try\n      #?(:clj  (UUID/fromString x)\n         ;; http://stackoverflow.com/questions/7905929/how-to-test-valid-uuid-guid\n         :cljs (if (re-find #\"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\" x)\n                 (uuid x)\n                 x))\n      (catch #?(:clj Exception, :cljs js/Error) _ x))\n    x))\n\n#?(:clj\n   (def ^DateTimeFormatter +string->date-format+\n     (-> (DateTimeFormatterBuilder.)\n         (.appendPattern \"yyyy-MM-dd['T'HH:mm:ss[.SSS][XXXX][XXXXX]]\")\n         (.parseDefaulting ChronoField/HOUR_OF_DAY 0)\n         (.parseDefaulting ChronoField/OFFSET_SECONDS 0)\n         (.toFormatter))))\n\n(defn string->date [_ x]\n  (if (string? x)\n    (try\n      #?(:clj  (Date/from (Instant/from (.parse +string->date-format+ x)))\n         :cljs (js/Date. (.getTime (goog.date.UtcDateTime.fromIsoString x))))\n      (catch #?(:clj Exception, :cljs js/Error) _ x))\n    x))\n\n#?(:clj\n   (def ^DateTimeFormatter +date->string-format+\n     (-> (DateTimeFormatter/ofPattern \"yyyy-MM-dd'T'HH:mm:ss.SSSXXX\")\n         (.withZone (ZoneId/of \"UTC\")))))\n\n(defn date->string [_ x]\n  (if (inst? x)\n    (try\n      #?(:clj  (.format +date->string-format+ (Instant/ofEpochMilli (inst-ms x)))\n         :cljs (.toISOString x))\n      (catch #?(:clj Exception, :cljs js/Error) _ x))\n    x))\n\n(defn string->symbol [_ x]\n  (if (string? x)\n    (symbol x)\n    x))\n\n(defn string->nil [_ x]\n  (if (= \"\" x)\n    nil\n    x))\n\n(defn any->string [_ x]\n  (if-not (nil? x)\n    (str x)))\n\n(defn number->double [_ x]\n  (if (number? x)\n    (double x)\n    x))\n\n(defn any->any [_ x] x)\n\n;;\n;; Maps\n;;\n\n(defn strip-extra-keys [{:keys [::parse/keys]} x]\n  (if (and keys (map? x))\n    (select-keys x keys)\n    x))\n\n;; TODO: remove this as it couples transformation & validation?\n(defn fail-on-extra-keys [{:keys [::parse/keys]} x]\n  (if (and (map? x) (not (set/subset? (-> x (clojure.core/keys) (set)) keys)))\n    ::s/invalid\n    x))\n\n;;\n;; Tuples\n;;\n\n(defn strip-extra-values [{:keys [::parse/items]} x]\n  (let [size (count items)]\n    (if (and (vector? x) (> (count x) size))\n      (subvec x 0 size)\n      x)))\n\n;;\n;; type decoders\n;;\n\n(def json-type-decoders\n  (merge\n    {:keyword string->keyword\n     :uuid (keyword-or-string-> string->uuid)\n     :date (keyword-or-string-> string->date)\n     :symbol (keyword-or-string-> string->symbol)\n     :long (keyword-> string->long)\n     :double (keyword-> string->double)\n     :boolean (keyword-> string->boolean)\n     :string keyword->string}\n    #?(:clj\n       {:uri nil\n        :bigdec nil\n        :ratio nil})))\n\n(def string-type-decoders\n  (merge\n    json-type-decoders\n    {:long (keyword-or-string-> string->long)\n     :double (keyword-or-string-> string->double)\n     :boolean (keyword-or-string-> string->boolean)}))\n\n(def strip-extra-keys-type-decoders\n  {:map strip-extra-keys})\n\n(def fail-on-extra-keys-type-decoders\n  {:map fail-on-extra-keys})\n\n(def strip-extra-values-type-decoders\n  {:tuple strip-extra-values})\n\n;;\n;; type encoders\n;;\n\n(def json-type-encoders\n  {:keyword keyword->string\n   :symbol any->string\n   :uuid any->string\n   :uri any->string\n   :bigdec any->string\n   :date date->string\n   :map any->any\n   :set any->any\n   :vector any->any\n   #?@(:clj [:ratio number->double])})\n\n(def string-type-encoders\n  (merge\n    json-type-encoders\n    {:long any->string\n     :double any->string}))\n"]}