{"version":3,"sources":["spec_tools/parse.cljc"],"mappings":"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","names":["spec-tools.parse/type-dispatch-value","type","fexpr__10676","cljs.core/sequential?","cljs.core/first","cljs.core/identity","spec-tools.parse/collection-type?","cljs.core/contains?","spec-tools.parse/leaf-type?","spec-tools.parse/non-leaf-types","spec-tools.parse/parse-spec","x","cljs.core._EQ_","cljs.core/qualified-keyword?","cljs.spec.alpha/form","cljs.spec.alpha/get-spec","cljs.core/Symbol","G__10677","G__10678","spec-tools.parse/parse-form","spec-tools.impl/normalize-symbol","cljs.core/seq?","G__10679","G__10680","cljs.spec.alpha/spec?","cljs.core/ifn?","G__10681","G__10682","spec-tools.form/resolve-form","spec-tools.parse/parse-spec-with-spec-ref","cljs.core.merge","spec-tools.parse/get-keys","parse-data","or__4185__auto__","G__10683","cljs.core.keep","cljs.core.apply","cljs.core/concat","cljs.core/seq","cljs.core/set","js/spec-tools","js/spec-tools.parse","js/spec-tools.parse.parse-form","method-table__4672__auto__","cljs.core.atom","prefer-table__4673__auto__","method-cache__4674__auto__","cached-hierarchy__4675__auto__","hierarchy__4676__auto__","cljs.core.get","fexpr__10684","cljs.core/MultiFn","cljs.core.symbol","dispatch","_","spec-tools.parse/types","spec-tools.parse/type-symbols","cljs.core/methods","cljs.core/keys","cljs.core.filter","cljs.core/symbol?","cljs.core/any?","cljs.core/some?","cljs.core/number?","cljs.core/integer?","cljs.core/int?","cljs.core/pos-int?","cljs.core/neg-int?","cljs.core/nat-int?","cljs.core/float?","cljs.core/double?","cljs.core/boolean?","cljs.core/string?","cljs.core/ident?","cljs.core/simple-ident?","cljs.core/qualified-ident?","cljs.core/keyword?","cljs.core/simple-keyword?","cljs.core/simple-symbol?","cljs.core/qualified-symbol?","cljs.core/uuid?","cljs.core/inst?","cljs.core/seqable?","cljs.core/indexed?","cljs.core/map?","cljs.core/vector?","cljs.core/list?","cljs.core/char?","cljs.core/set?","cljs.core/nil?","cljs.core/false?","cljs.core/true?","cljs.core/zero?","cljs.core/coll?","cljs.core/empty?","cljs.core/associative?","form","map__10694","cljs.core/PROTOCOL_SENTINEL","cljs.core/hash-map","req","opt","req-un","opt-un","key->spec","spec-tools.impl/parse-keys","G__10696","cljs.core.concat","cljs.core.assoc","specs","cljs.core.mapv","cljs.core.comp","cljs.core/second","cljs.core.partition","cljs.core/rest","cljs.core.map","cljs.core.distinct","cljs.core/vec","types","spec-tools.impl/deep-merge","map__10697","into","cljs.core.drop","map__10699","p__10701","vec__10702","cljs.core.nth","k","v","parsed","cljs.core/last","p__10708","vec__10709","seq__10710","first__10711","cljs.core/next","values","spec"],"sourcesContent":["(ns spec-tools.parse\n  (:require [spec-tools.impl :as impl]\n            [clojure.spec.alpha :as s]\n            [spec-tools.form :as form]))\n\n(declare parse-form)\n(declare non-leaf-types)\n\n(defn type-dispatch-value [type]\n  ((if (sequential? type) first identity) type))\n\n(defn collection-type? [type]\n  (contains? #{:map :map-of :set :vector :tuple} type))\n\n(defn leaf-type? [type]\n  (not (contains? (non-leaf-types) type)))\n\n(defn parse-spec\n  \"Parses info out of a spec. Spec can be passed as a name, Spec or a form.\n  Returns either `nil` or a map, with keys `:type` and other extra keys\n  (like `:keys` for s/keys specs).\"\n  [x]\n  (cond\n\n    ;; unknown\n    (= ::s/unknown x)\n    nil\n\n    ;; spec name\n    (qualified-keyword? x)\n    (recur (s/form (s/get-spec x)))\n\n    ;; symbol\n    (symbol? x)\n    (parse-form (impl/normalize-symbol x) nil)\n\n    ;; a from\n    (seq? x)\n    (parse-form (impl/normalize-symbol (first x)) x)\n\n    ;; a spec\n    (s/spec? x)\n    (recur (s/form x))\n\n    ;; a predicate\n    (ifn? x)\n    (parse-form (form/resolve-form x) nil)\n\n    ;; default\n    :else (parse-form x nil)))\n\n(defn parse-spec-with-spec-ref [x]\n  (merge (parse-spec x) (if (qualified-keyword? x) {:spec x})))\n\n(defn get-keys [parse-data]\n  (or (::keys parse-data)\n      (some->> parse-data ::items (keep get-keys) (apply concat) (seq) (set))))\n\n(defmulti parse-form (fn [dispatch _] dispatch) :default ::default)\n\n(defmethod parse-form ::default [_ _] {:type nil})\n\n(defn- non-leaf-types []\n  #{:map :map-of :and :or :nilable :tuple :set :vector})\n\n(defn types []\n  #{:long\n    :double\n    :boolean\n    :string\n    :keyword\n    :symbol\n    :uuid\n    :uri\n    :bigdec\n    :date\n    :ratio\n    :map\n    :map-of\n    :and\n    :or\n    :set\n    :tuple\n    :nilable\n    :vector\n    :spec})\n\n(defn type-symbols []\n  (-> parse-form\n      methods\n      keys\n      (->> (filter symbol?))\n      set))\n\n(defmethod parse-form 'clojure.core/any?               [_ _] {:spec any?})\n(defmethod parse-form 'clojure.core/some?              [_ _] {:spec some?})\n(defmethod parse-form 'clojure.core/number?            [_ _] {:spec number?, :type :double})\n(defmethod parse-form 'clojure.core/integer?           [_ _] {:spec integer?, :type :long})\n(defmethod parse-form 'clojure.core/int?               [_ _] {:spec int?, :type :long})\n(defmethod parse-form 'clojure.core/pos-int?           [_ _] {:spec pos-int?, :type :long})\n(defmethod parse-form 'clojure.core/neg-int?           [_ _] {:spec neg-int?, :type :long})\n(defmethod parse-form 'clojure.core/nat-int?           [_ _] {:spec nat-int?, :type :long})\n(defmethod parse-form 'clojure.core/float?             [_ _] {:spec float?, :type :double})\n(defmethod parse-form 'clojure.core/double?            [_ _] {:spec double?, :type :double})\n(defmethod parse-form 'clojure.core/boolean?           [_ _] {:spec boolean?, :type :boolean})\n(defmethod parse-form 'clojure.core/string?            [_ _] {:spec string?, :type :string})\n(defmethod parse-form 'clojure.core/ident?             [_ _] {:spec ident? :type :keyword})\n(defmethod parse-form 'clojure.core/simple-ident?      [_ _] {:spec simple-ident?, :type :keyword})\n(defmethod parse-form 'clojure.core/qualified-ident?   [_ _] {:spec qualified-ident?, :type :keyword})\n(defmethod parse-form 'clojure.core/keyword?           [_ _] {:spec keyword?, :type :keyword})\n(defmethod parse-form 'clojure.core/simple-keyword?    [_ _] {:spec simple-keyword?, :type :keyword})\n(defmethod parse-form 'clojure.core/qualified-keyword? [_ _] {:spec qualified-keyword? :type :keyword})\n(defmethod parse-form 'clojure.core/symbol?            [_ _] {:spec symbol?, :type :symbol})\n(defmethod parse-form 'clojure.core/simple-symbol?     [_ _] {:spec simple-symbol?, :type :symbol})\n(defmethod parse-form 'clojure.core/qualified-symbol?  [_ _] {:spec qualified-symbol?, :type :symbol})\n(defmethod parse-form 'clojure.core/uuid?              [_ _] {:spec uuid?, :type :uuid})\n#?(:clj (defmethod parse-form 'clojure.core/uri?       [_ _] {:spec uri?, :type :uri}))\n#?(:clj (defmethod parse-form 'clojure.core/decimal?   [_ _] {:spec decimal?, :type :bigdec}))\n(defmethod parse-form 'clojure.core/inst?              [_ _] {:spec inst?, :type :date})\n(defmethod parse-form 'clojure.core/seqable?           [_ _] {:spec seqable?})\n(defmethod parse-form 'clojure.core/indexed?           [_ _] {:spec indexed?})\n(defmethod parse-form 'clojure.core/map?               [_ _] {:spec map?})\n(defmethod parse-form 'clojure.core/vector?            [_ _] {:spec vector?})\n(defmethod parse-form 'clojure.core/list?              [_ _] {:spec list?})\n(defmethod parse-form 'clojure.core/seq?               [_ _] {:spec seq?})\n(defmethod parse-form 'clojure.core/char?              [_ _] {:spec char?})\n(defmethod parse-form 'clojure.core/set?               [_ _] {:spec set?})\n(defmethod parse-form 'clojure.core/nil?               [_ _] {:spec nil?})\n(defmethod parse-form 'clojure.core/false?             [_ _] {:spec false?, :type :boolean})\n(defmethod parse-form 'clojure.core/true?              [_ _] {:spec true?, :type :boolean})\n(defmethod parse-form 'clojure.core/zero?              [_ _] {:spec zero?, :type :long})\n#?(:clj (defmethod parse-form 'clojure.core/rational?  [_ _] {:spec rational?, :type :long}))\n(defmethod parse-form 'clojure.core/coll?              [_ _] {:spec coll?})\n(defmethod parse-form 'clojure.core/empty?             [_ _] {:spec empty?})\n(defmethod parse-form 'clojure.core/associative?       [_ _] {:spec associative?, :type nil})\n(defmethod parse-form 'clojure.core/sequential?        [_ _] {:spec sequential?})\n#?(:clj (defmethod parse-form 'clojure.core/ratio?     [_ _] {:spec ratio?, :type :ratio}))\n#?(:clj (defmethod parse-form 'clojure.core/bytes?     [_ _] {:spec bytes?}))\n\n(defmethod parse-form :clojure.spec.alpha/unknown [_ _])\n\n(defmethod parse-form 'clojure.spec.alpha/keys [_ form]\n  (let [{:keys [req opt req-un opt-un key->spec]} (impl/parse-keys form)]\n    (cond-> {:type :map\n             ::key->spec key->spec\n             ::keys (set (concat req opt req-un opt-un))}\n            (or req req-un) (assoc ::keys-req (set (concat req req-un)))\n            (or opt opt-un) (assoc ::keys-opt (set (concat opt opt-un))))))\n\n(defmethod parse-form 'clojure.spec.alpha/or [_ form]\n  (let [specs (mapv (comp parse-spec-with-spec-ref second) (partition 2 (rest form)))]\n    {:type [:or (->> specs (map :type) (distinct) (keep identity) (vec))]\n     ::items specs}))\n\n(defmethod parse-form 'clojure.spec.alpha/and [_ form]\n  (let [specs (mapv parse-spec-with-spec-ref (rest form))\n        types (->> specs (map :type) (distinct) (keep identity) (vec))]\n    {:type [:and types]\n     ::items specs}))\n\n(defmethod parse-form 'clojure.spec.alpha/merge [_ form]\n  (apply impl/deep-merge (map parse-spec (rest form))))\n\n(defmethod parse-form 'clojure.spec.alpha/every [_ form]\n  (let [{:keys [into]} (apply hash-map (drop 2 form))]\n    {::item (parse-spec (second form))\n     :type\n     (cond\n       (map? into) :map-of\n       (set? into) :set\n       :else :vector)}))\n\n; every-ks\n\n(defmethod parse-form 'clojure.spec.alpha/coll-of [_ form]\n  (let [{:keys [into]} (apply hash-map (drop 2 form))]\n    {::item (parse-spec-with-spec-ref (second form))\n     :type\n     (cond\n       (map? into) :map-of\n       (set? into) :set\n       :else :vector)}))\n\n(defmethod parse-form 'clojure.spec.alpha/map-of [_ [_ k v]]\n  {:type :map-of\n   ::key (parse-spec-with-spec-ref k)\n   ::value (parse-spec-with-spec-ref v)})\n\n(defmethod parse-form 'spec-tools.core/spec [_ form]\n  (let [parsed (-> form last :spec parse-spec)]\n    (if (:type parsed) parsed {:type :spec})))\n\n; *\n; +\n; ?\n; alt\n; cat\n; &\n; keys*\n\n(defmethod parse-form 'clojure.spec.alpha/tuple [_ [_ & values]]\n  (let [specs (mapv parse-spec-with-spec-ref values)\n        types (mapv :type specs)]\n    {:type [:tuple types]\n     ::items specs}))\n\n(defmethod parse-form 'clojure.spec.alpha/nilable [_ form]\n  (let [spec (-> form second parse-spec-with-spec-ref)]\n    {:type :nilable\n     ::item spec}))\n\n(defmethod parse-form 'spec-tools.core/merge [_ form]\n  (apply impl/deep-merge (map parse-spec (rest form))))\n"]}