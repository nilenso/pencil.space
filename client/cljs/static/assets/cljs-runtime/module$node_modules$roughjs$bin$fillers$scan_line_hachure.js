shadow$provide.module$node_modules$roughjs$bin$fillers$scan_line_hachure=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj};return _typeof(obj$jscomp$0)}function _toConsumableArray(arr){if(Array.isArray(arr)){var JSCompiler_temp=0;for(var arr2=Array(arr.length);JSCompiler_temp<
arr.length;JSCompiler_temp++)arr2[JSCompiler_temp]=arr[JSCompiler_temp];JSCompiler_temp=arr2}else JSCompiler_temp=void 0;JSCompiler_temp||(JSCompiler_temp=Symbol.iterator in Object(arr)||"[object Arguments]"===Object.prototype.toString.call(arr)?Array.from(arr):void 0);if(!(arr=JSCompiler_temp))throw new TypeError("Invalid attempt to spread non-iterable instance");return arr}function straightHachureLines(points,o){var vertices=_toConsumableArray(points);vertices[0].join(",")!==vertices[vertices.length-
1].join(",")&&vertices.push([vertices[0][0],vertices[0][1]]);var lines=[];return vertices&&2<vertices.length&&(points=function(){var gap=o.hachureGap;0>gap&&(gap=4*o.strokeWidth);gap=Math.max(gap,.1);for(var edges=[],i=0;i<vertices.length-1;i++){var p1=vertices[i],p2=vertices[i+1];if(p1[1]!==p2[1]){var ymin=Math.min(p1[1],p2[1]);edges.push({ymin:ymin,ymax:Math.max(p1[1],p2[1]),x:ymin===p1[1]?p1[0]:p2[0],islope:(p2[0]-p1[0])/(p2[1]-p1[1])})}}edges.sort(function(e1,e2){return e1.ymin<e2.ymin?-1:e1.ymin>
e2.ymin?1:e1.x<e2.x?-1:e1.x>e2.x?1:e1.ymax===e2.ymax?0:(e1.ymax-e2.ymax)/Math.abs(e1.ymax-e2.ymax)});if(!edges.length)return{v:lines};for(var activeEdges=[],y=edges[0].ymin;activeEdges.length||edges.length;){if(edges.length){i=-1;for(p1=0;p1<edges.length&&!(edges[p1].ymin>y);p1++)i=p1;edges.splice(0,i+1).forEach(function(edge){activeEdges.push({s:y,edge:edge})})}activeEdges=activeEdges.filter(function(ae){return ae.edge.ymax<=y?!1:!0});activeEdges.sort(function(ae1,ae2){return ae1.edge.x===ae2.edge.x?
0:(ae1.edge.x-ae2.edge.x)/Math.abs(ae1.edge.x-ae2.edge.x)});if(1<activeEdges.length)for(i=0;i<activeEdges.length;i+=2){p1=i+1;if(p1>=activeEdges.length)break;lines.push([[Math.round(activeEdges[i].edge.x),y],[Math.round(activeEdges[p1].edge.x),y]])}y+=gap;activeEdges.forEach(function(ae){ae.edge.x+=gap*ae.edge.islope})}}(),"object"===_typeof(points))?points.v:lines}Object.defineProperty(exports,"__esModule",{value:!0});exports.polygonHachureLines=function(points,o){var rotationCenter=[0,0],angle=
Math.round(o.hachureAngle+90);angle&&(0,_geometry.rotatePoints)(points,rotationCenter,angle);o=straightHachureLines(points,o);angle&&((0,_geometry.rotatePoints)(points,rotationCenter,-angle),(0,_geometry.rotateLines)(o,rotationCenter,-angle));return o};var _geometry=require("module$node_modules$roughjs$bin$geometry")}
//# sourceMappingURL=module$node_modules$roughjs$bin$fillers$scan_line_hachure.js.map
